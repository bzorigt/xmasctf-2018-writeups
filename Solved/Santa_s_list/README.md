# Santa's list
Crypto

## Challenge 

	Santa's database got corrupted and now he doesn't know who was nice anymore... Can you help him find out if Galf was nice?

	Server: nc 199.247.6.180 16001

	santas_list.zip 
	Author: SoulTaku

## Solution

### Situation

We are given an RSA encrypt/decrypt box. And it appears to be an [RSA Chosen Ciphertext Attack](https://crypto.stackexchange.com/a/2331).

However, they do not allow decryption where the plaintext is a multiple of the flag. This means we can't do the typical RSA-CCA.

	# As seen here...

    for no in used:
        if m % no == 0:
            print('Ho, ho, no...')
            break

However, after days of consideration and brainstorming, I realised we can do the "reverse" of Chosen Ciphertext Attack.

### "Reverse" Chosen Ciphertext Attack

Reference: https://crypto.stackexchange.com/questions/20789/decrypt-all-rsa-ciphertexts-if-you-can-break-1-of-them

I have come up with this plan...

	All calculations are done (mod N)

	Let the following equations be true:
	C[flag] = C[f1] * C[f2]
	M[flag] = M[f1] * M[f2]

	Given C[flag] = encrypted flag
	Factorise C[flag] to get 2 items:
		C[f1] and C[f2]

	Then we decrypt the 2 items.
		M[f1] and M[f2]

	After which, multiply them and mod N
		M[flag] == (M[f1] * M[f2]) % N

The plan seems to work in my initial test values.

---

### Find modulus

Now, we also need to find `N` which is not given.

I tried some math and the following works.

	# Encrypt of '\x05' -> r5
	# Encrypt of '\x06' -> r6

	>>> import gmpy2

	>>> r5 = ???
	>>> r6 = ???

	>>> gmpy2.gcd(pow(5,e) - r5, pow(6,e) - r6)
	mpz(???)

---

### Solving actual...

I did all manually...

Connect to server and get the ciphertext

	$ nc 199.247.6.180 16001
	Ho, ho, ho and welcome back!
	Your list for this year:

	Sarah - Nice
	Bob - Nice
	Eve - Naughty
	Galf - f2fd415a6e0c5623b497f7235be240623f275e320e154b70b5d45a1ade4e28427df30d3e7bf7e5fbfd68149f04baf494b98753cc54d14517cd9173216341a038397c4c8ceaba449480ade28d7bbdfa7fa1ae2ac056c93b9bee1c4f34a41dae7c364d12b9396706c5cbecb03e784bff4342c93910e108942d6ecc584efcca08b

Factor in YAFU. I aborted the process early since I only need one factor.

	# ./yafu

	>> factor(0xf2fd415a6e0c5623b497f7235be240623f275e320e154b70b5d45a1ade4e28427df30d3e7bf7e5fbfd68149f04baf494b98753cc54d14517cd9173216341a038397c4c8ceaba449480ade28d7bbdfa7fa1ae2ac056c93b9bee1c4f34a41dae7c364d12b9396706c5cbecb03e784bff4342c93910e108942d6ecc584efcca08b)

	...
	
	***factors found***

	P2 = 29
	P3 = 223
	P3 = 751
	P5 = 26729

	***co-factor***
	C296 = 82151824756228727408106328308162134333077544734906189116346152440283489181662242937893065853451260081966033484178238882413001311929249363377455231601442669632679577620277912051401471283233645575955623682607596716035638510026247227438165439350518010368724850916381866289145363070615123627839229919

With this, we get the 2 ciphertext items.

	>>> c = 0xf2fd415a6e0c5623b497f7235be240623f275e320e154b70b5d45a1ade4e28427df30d3e7bf7e5fbfd68149f04baf494b98753cc54d14517cd9173216341a038397c4c8ceaba449480ade28d7bbdfa7fa1ae2ac056c93b9bee1c4f34a41dae7c364d12b9396706c5cbecb03e784bff4342c93910e108942d6ecc584efcca08b

	>>> c1 = 223

	>>> c2 = c // c1
	47823114942619286885877057520768945831776121888623298671713088384484051849909902342494148087991257456587620103880512603429924683697542860864100783284759178158690405237596040610101976276819715460309255390817061479674500233595491731894858894614523510687493035997795542319143053832815677835549203317501327829


Now decrypt both c1 and c2...

	Ciphertext > 47823114942619286885877057520768945831776121888623298671713088384484051849909902342494148087991257456587620103880512603429924683697542860864100783284759178158690405237596040610101976276819715460309255390817061479674500233595491731894858894614523510687493035997795542319143053832815677835549203317501327829

	Decrypted: 101280925171264704329085164655893239381566769220153218073971909648728260523427357822100745745045879966104072532786549955300550865293833392405347028755118998178533675693806835243113438385142246888482525667252733456462462310471596816302324657510258549361065878106378609322568909416881507894646079979472232376718

	---

	Ciphertext > 223

	Decrypted: 129418290535726440010316171066610977160276141467071427263188658822154733667660863074687170497878546150130281541105318907336864161983156421256721950098594256839632140347879312967288482497280402239559850993715653576400249078329470151693368720311315824978924206995551615226371723813504532819702591464212147397188


Then we need to find modulus, `N`.

	Plaintext > ^E

	Encrypted: 81982030759417899006939969108879569067866542601369328322421777556163382642624925702082236765879450579461252880696565724577202803364841394962817006169786330056716923693434084936134358404588983469709943843579815363551869668338700441367971672564970642457465461806433428598562054802867324916445767209576009104761

	[1] Encrypt
	[2] Decrypt
	[3] Exit
	1

	Plaintext > ^F

	Encrypted: 54430622920114445416958888222384338272909346119818238972943793874828091964153529836024351439949103897073039217113793683065646695812122352876297407480545779092612622782762607551829702559372714928171589136370009231295661074842320440160628260402978502164995651246636853954367399735855159542549029435244293471143

	[1] Encrypt
	[2] Decrypt
	[3] Exit


Finally put all into Python to calculate:

First, get the modulus N.

	>>> import gmpy2

	>>> r5 = 81982030759417899006939969108879569067866542601369328322421777556163382642624925702082236765879450579461252880696565724577202803364841394962817006169786330056716923693434084936134358404588983469709943843579815363551869668338700441367971672564970642457465461806433428598562054802867324916445767209576009104761
	>>> r6 = 54430622920114445416958888222384338272909346119818238972943793874828091964153529836024351439949103897073039217113793683065646695812122352876297407480545779092612622782762607551829702559372714928171589136370009231295661074842320440160628260402978502164995651246636853954367399735855159542549029435244293471143

	>>> N = gmpy2.gcd(pow(5,e) - r5, pow(6,e) - r6)

Next, calculate the message

	>>> M_p1 = 101280925171264704329085164655893239381566769220153218073971909648728260523427357822100745745045879966104072532786549955300550865293833392405347028755118998178533675693806835243113438385142246888482525667252733456462462310471596816302324657510258549361065878106378609322568909416881507894646079979472232376718
	>>> M_p2 = 129418290535726440010316171066610977160276141467071427263188658822154733667660863074687170497878546150130281541105318907336864161983156421256721950098594256839632140347879312967288482497280402239559850993715653576400249078329470151693368720311315824978924206995551615226371723813504532819702591464212147397188

	>>> M = (M_p1 * M_p2) % N
	>>> M
	mpz(70468172101464206057749347109509757141237106513489470800235950596544765767485601207906004115252449957267397964196107604819684837277082305273533002621)

	>>> bytes.fromhex( hex(M)[2:])
	b'X-MAS{N1c3_bu7_chr1s7m4s_is_n0t_ab0u7_g1f7s_17_1s_ab0u7_fl4gs}'

## Flag

	X-MAS{N1c3_bu7_chr1s7m4s_is_n0t_ab0u7_g1f7s_17_1s_ab0u7_fl4gs}
